'use strict';
/**
 * Automatically try to determine what type of time the input is and run the conversion
 * to make it the specified type.
 * 
 * This is easier to use but also reduces readability, in my opinion.
 * 
 * @param {number|string} time The time in milliseconds or a string to convert to the other type.
 * @param {boolean} ms Indicates whether the time be returned as milliseconds or as 'hh:mm:ss'.
 * 
 * @returns {number|string}
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = auto;

function auto(time) {
  var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (isNumeric(time)) {
    time = parseFloat(time.toString());
    if (ms) return time;else return msToTime(time);
  } else {
    if (!ms) return time;else return timeToMs(time.toString());
  }
}
/**
 * Convert a time value from milliseconds to a 'hh:mm:ss' format.
 * 
 * @param {number|string} ms The time might be in milliseconds but it could still be in a string.
 * 
 * @returns {string} The time in 'hh:mm:ss' format.
 */


function msToTime(ms) {
  var hh = Math.floor(parseInt(ms.toString()) / 1000 / 3600);
  var mm = Math.floor(parseInt(ms.toString()) / 1000 / 60 % 60);
  var ss = Math.floor(parseInt(ms.toString()) / 1000 % 60);
  return "".concat(pad(hh), ":").concat(pad(mm), ":").concat(pad(ss));
}
/**
 * Convert a time value from 'hh:mm:ss' format to milliseconds.
 * 
 * @param {string} time The time might be in 'hh:mm:ss' format.
 * 
 * @returns {number} The time in milliseconds.
 */


function timeToMs(time) {
  var hhIndex = time.indexOf(':');
  var mmIndex = time.indexOf(':', hhIndex + 1);
  var ssIndex = time.indexOf(':', mmIndex);
  var hh = parseInt(time.slice(0, hhIndex));
  var mm = parseInt(time.slice(hhIndex + 1, ssIndex));
  var ss = parseInt(time.slice(ssIndex + 1));
  hh *= 3.6 * Math.pow(10, 6);
  mm *= 60000;
  ss *= 1000;
  return hh + mm + ss;
}
/**
 * Check if a provided value is a number.
 * 
 * @param {*} n The value to check.
 * 
 * @returns {boolean} True if the value is a number and false otherwise.
 */


var isNumeric = function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
};
/**
 * Add a leading 0 to a number below 10.
 * 
 * @param {number} n The number to add a leading zero to.
 * 
 * @returns {string|number} The padded or original number.
 */


var pad = function pad(n) {
  if (n < 10) return "0".concat(n);
  return n;
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9jb252ZXJ0LnRzIl0sIm5hbWVzIjpbImF1dG8iLCJ0aW1lIiwibXMiLCJpc051bWVyaWMiLCJwYXJzZUZsb2F0IiwidG9TdHJpbmciLCJtc1RvVGltZSIsInRpbWVUb01zIiwiaGgiLCJNYXRoIiwiZmxvb3IiLCJwYXJzZUludCIsIm1tIiwic3MiLCJwYWQiLCJoaEluZGV4IiwiaW5kZXhPZiIsIm1tSW5kZXgiLCJzc0luZGV4Iiwic2xpY2UiLCJuIiwiaXNOYU4iLCJpc0Zpbml0ZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXZSxTQUFTQSxJQUFULENBQWNDLElBQWQsRUFBOEU7QUFBQSxNQUF2Q0MsRUFBdUMsdUVBQXpCLElBQXlCOztBQUUzRixNQUFJQyxTQUFTLENBQUNGLElBQUQsQ0FBYixFQUFxQjtBQUVuQkEsSUFBQUEsSUFBSSxHQUFHRyxVQUFVLENBQUNILElBQUksQ0FBQ0ksUUFBTCxFQUFELENBQWpCO0FBRUEsUUFBSUgsRUFBSixFQUFRLE9BQU9ELElBQVAsQ0FBUixLQUVLLE9BQU9LLFFBQVEsQ0FBQ0wsSUFBRCxDQUFmO0FBRU4sR0FSRCxNQVVLO0FBRUgsUUFBSSxDQUFDQyxFQUFMLEVBQVMsT0FBT0QsSUFBUCxDQUFULEtBRUssT0FBT00sUUFBUSxDQUFDTixJQUFJLENBQUNJLFFBQUwsRUFBRCxDQUFmO0FBRU47QUFFRjtBQUVEOzs7Ozs7Ozs7QUFPQSxTQUFTQyxRQUFULENBQWtCSixFQUFsQixFQUFpRDtBQUUvQyxNQUFNTSxFQUFVLEdBQUdDLElBQUksQ0FBQ0MsS0FBTCxDQUFhQyxRQUFRLENBQUNULEVBQUUsQ0FBQ0csUUFBSCxFQUFELENBQVIsR0FBMEIsSUFBM0IsR0FBbUMsSUFBL0MsQ0FBbkI7QUFDQSxNQUFNTyxFQUFVLEdBQUdILElBQUksQ0FBQ0MsS0FBTCxDQUFjQyxRQUFRLENBQUNULEVBQUUsQ0FBQ0csUUFBSCxFQUFELENBQVIsR0FBMEIsSUFBM0IsR0FBbUMsRUFBcEMsR0FBMEMsRUFBdEQsQ0FBbkI7QUFDQSxNQUFNUSxFQUFVLEdBQUdKLElBQUksQ0FBQ0MsS0FBTCxDQUFhQyxRQUFRLENBQUNULEVBQUUsQ0FBQ0csUUFBSCxFQUFELENBQVIsR0FBMEIsSUFBM0IsR0FBbUMsRUFBL0MsQ0FBbkI7QUFFQSxtQkFBVVMsR0FBRyxDQUFDTixFQUFELENBQWIsY0FBcUJNLEdBQUcsQ0FBQ0YsRUFBRCxDQUF4QixjQUFnQ0UsR0FBRyxDQUFDRCxFQUFELENBQW5DO0FBRUQ7QUFFRDs7Ozs7Ozs7O0FBT0EsU0FBU04sUUFBVCxDQUFrQk4sSUFBbEIsRUFBd0M7QUFFdEMsTUFBTWMsT0FBZSxHQUFHZCxJQUFJLENBQUNlLE9BQUwsQ0FBYSxHQUFiLENBQXhCO0FBQ0EsTUFBTUMsT0FBZSxHQUFHaEIsSUFBSSxDQUFDZSxPQUFMLENBQWEsR0FBYixFQUFrQkQsT0FBTyxHQUFHLENBQTVCLENBQXhCO0FBQ0EsTUFBTUcsT0FBZSxHQUFHakIsSUFBSSxDQUFDZSxPQUFMLENBQWEsR0FBYixFQUFrQkMsT0FBbEIsQ0FBeEI7QUFFQSxNQUFJVCxFQUFVLEdBQUdHLFFBQVEsQ0FBQ1YsSUFBSSxDQUFDa0IsS0FBTCxDQUFXLENBQVgsRUFBY0osT0FBZCxDQUFELENBQXpCO0FBQ0EsTUFBSUgsRUFBVSxHQUFHRCxRQUFRLENBQUNWLElBQUksQ0FBQ2tCLEtBQUwsQ0FBV0osT0FBTyxHQUFHLENBQXJCLEVBQXdCRyxPQUF4QixDQUFELENBQXpCO0FBQ0EsTUFBSUwsRUFBVSxHQUFHRixRQUFRLENBQUNWLElBQUksQ0FBQ2tCLEtBQUwsQ0FBV0QsT0FBTyxHQUFHLENBQXJCLENBQUQsQ0FBekI7QUFFQVYsRUFBQUEsRUFBRSxJQUFLLGVBQU8sRUFBUCxFQUFhLENBQWIsQ0FBUDtBQUNBSSxFQUFBQSxFQUFFLElBQUksS0FBTjtBQUNBQyxFQUFBQSxFQUFFLElBQUksSUFBTjtBQUVBLFNBQU9MLEVBQUUsR0FBR0ksRUFBTCxHQUFVQyxFQUFqQjtBQUVEO0FBRUQ7Ozs7Ozs7OztBQU9BLElBQU1WLFNBQVMsR0FBRyxTQUFaQSxTQUFZLENBQUNpQixDQUFELEVBQXFCO0FBRXJDLFNBQU8sQ0FBQ0MsS0FBSyxDQUFDakIsVUFBVSxDQUFDZ0IsQ0FBRCxDQUFYLENBQU4sSUFBeUJFLFFBQVEsQ0FBQ0YsQ0FBRCxDQUF4QztBQUVELENBSkQ7QUFNQTs7Ozs7Ozs7O0FBT0EsSUFBTU4sR0FBRyxHQUFHLFNBQU5BLEdBQU0sQ0FBQ00sQ0FBRCxFQUFrQztBQUU1QyxNQUFJQSxDQUFDLEdBQUcsRUFBUixFQUFZLGtCQUFXQSxDQUFYO0FBRVosU0FBT0EsQ0FBUDtBQUVELENBTkQiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcclxuXHJcbi8qKlxyXG4gKiBBdXRvbWF0aWNhbGx5IHRyeSB0byBkZXRlcm1pbmUgd2hhdCB0eXBlIG9mIHRpbWUgdGhlIGlucHV0IGlzIGFuZCBydW4gdGhlIGNvbnZlcnNpb25cclxuICogdG8gbWFrZSBpdCB0aGUgc3BlY2lmaWVkIHR5cGUuXHJcbiAqIFxyXG4gKiBUaGlzIGlzIGVhc2llciB0byB1c2UgYnV0IGFsc28gcmVkdWNlcyByZWFkYWJpbGl0eSwgaW4gbXkgb3Bpbmlvbi5cclxuICogXHJcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdGltZSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgb3IgYSBzdHJpbmcgdG8gY29udmVydCB0byB0aGUgb3RoZXIgdHlwZS5cclxuICogQHBhcmFtIHtib29sZWFufSBtcyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGltZSBiZSByZXR1cm5lZCBhcyBtaWxsaXNlY29uZHMgb3IgYXMgJ2hoOm1tOnNzJy5cclxuICogXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ8c3RyaW5nfVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0byh0aW1lOiAobnVtYmVyIHwgc3RyaW5nKSwgbXM6IGJvb2xlYW4gPSB0cnVlKTogKG51bWJlciB8IHN0cmluZykge1xyXG5cclxuICBpZiAoaXNOdW1lcmljKHRpbWUpKSB7XHJcblxyXG4gICAgdGltZSA9IHBhcnNlRmxvYXQodGltZS50b1N0cmluZygpKTtcclxuXHJcbiAgICBpZiAobXMpIHJldHVybiB0aW1lO1xyXG5cclxuICAgIGVsc2UgcmV0dXJuIG1zVG9UaW1lKHRpbWUpO1xyXG5cclxuICB9XHJcblxyXG4gIGVsc2Uge1xyXG5cclxuICAgIGlmICghbXMpIHJldHVybiB0aW1lO1xyXG5cclxuICAgIGVsc2UgcmV0dXJuIHRpbWVUb01zKHRpbWUudG9TdHJpbmcoKSk7XHJcblxyXG4gIH1cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgdGltZSB2YWx1ZSBmcm9tIG1pbGxpc2Vjb25kcyB0byBhICdoaDptbTpzcycgZm9ybWF0LlxyXG4gKiBcclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtcyBUaGUgdGltZSBtaWdodCBiZSBpbiBtaWxsaXNlY29uZHMgYnV0IGl0IGNvdWxkIHN0aWxsIGJlIGluIGEgc3RyaW5nLlxyXG4gKiBcclxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHRpbWUgaW4gJ2hoOm1tOnNzJyBmb3JtYXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBtc1RvVGltZShtczogKG51bWJlciB8IHN0cmluZykpOiBzdHJpbmcge1xyXG5cclxuICBjb25zdCBoaDogbnVtYmVyID0gTWF0aC5mbG9vcigoKHBhcnNlSW50KG1zLnRvU3RyaW5nKCkpIC8gMTAwMCkgLyAzNjAwKSk7XHJcbiAgY29uc3QgbW06IG51bWJlciA9IE1hdGguZmxvb3IoKCgocGFyc2VJbnQobXMudG9TdHJpbmcoKSkgLyAxMDAwKSAvIDYwKSAlIDYwKSk7XHJcbiAgY29uc3Qgc3M6IG51bWJlciA9IE1hdGguZmxvb3IoKChwYXJzZUludChtcy50b1N0cmluZygpKSAvIDEwMDApICUgNjApKTtcclxuXHJcbiAgcmV0dXJuIGAke3BhZChoaCl9OiR7cGFkKG1tKX06JHtwYWQoc3MpfWA7XHJcblxyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBhIHRpbWUgdmFsdWUgZnJvbSAnaGg6bW06c3MnIGZvcm1hdCB0byBtaWxsaXNlY29uZHMuXHJcbiAqIFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGltZSBUaGUgdGltZSBtaWdodCBiZSBpbiAnaGg6bW06c3MnIGZvcm1hdC5cclxuICogXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcy5cclxuICovXHJcbmZ1bmN0aW9uIHRpbWVUb01zKHRpbWU6IHN0cmluZyk6IG51bWJlciB7XHJcblxyXG4gIGNvbnN0IGhoSW5kZXg6IG51bWJlciA9IHRpbWUuaW5kZXhPZignOicpO1xyXG4gIGNvbnN0IG1tSW5kZXg6IG51bWJlciA9IHRpbWUuaW5kZXhPZignOicsIGhoSW5kZXggKyAxKTtcclxuICBjb25zdCBzc0luZGV4OiBudW1iZXIgPSB0aW1lLmluZGV4T2YoJzonLCBtbUluZGV4KTtcclxuXHJcbiAgbGV0IGhoOiBudW1iZXIgPSBwYXJzZUludCh0aW1lLnNsaWNlKDAsIGhoSW5kZXgpKTtcclxuICBsZXQgbW06IG51bWJlciA9IHBhcnNlSW50KHRpbWUuc2xpY2UoaGhJbmRleCArIDEsIHNzSW5kZXgpKTtcclxuICBsZXQgc3M6IG51bWJlciA9IHBhcnNlSW50KHRpbWUuc2xpY2Uoc3NJbmRleCArIDEpKTtcclxuXHJcbiAgaGggKj0gKDMuNiAqICgxMCAqKiA2KSk7XHJcbiAgbW0gKj0gNjAwMDA7XHJcbiAgc3MgKj0gMTAwMDtcclxuXHJcbiAgcmV0dXJuIGhoICsgbW0gKyBzcztcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHByb3ZpZGVkIHZhbHVlIGlzIGEgbnVtYmVyLlxyXG4gKiBcclxuICogQHBhcmFtIHsqfSBuIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxuY29uc3QgaXNOdW1lcmljID0gKG46IGFueSk6IGJvb2xlYW4gPT4ge1xyXG5cclxuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIEFkZCBhIGxlYWRpbmcgMCB0byBhIG51bWJlciBiZWxvdyAxMC5cclxuICogXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgdG8gYWRkIGEgbGVhZGluZyB6ZXJvIHRvLlxyXG4gKiBcclxuICogQHJldHVybnMge3N0cmluZ3xudW1iZXJ9IFRoZSBwYWRkZWQgb3Igb3JpZ2luYWwgbnVtYmVyLlxyXG4gKi9cclxuY29uc3QgcGFkID0gKG46IG51bWJlcik6IChzdHJpbmcgfCBudW1iZXIpID0+IHtcclxuXHJcbiAgaWYgKG4gPCAxMCkgcmV0dXJuIGAwJHtufWA7XHJcblxyXG4gIHJldHVybiBuO1xyXG5cclxufSJdfQ==